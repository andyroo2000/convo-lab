// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       String    @id @default(uuid())
  email                    String    @unique
  password                 String?   // Optional for OAuth users
  name                     String
  displayName              String?
  avatarColor              String?   @default("indigo")
  avatarUrl                String?   // Custom profile avatar URL
  role                     String    @default("user") // "user", "moderator", "admin"
  preferredStudyLanguage   String    @default("ja") // 'ja' or 'zh'
  preferredNativeLanguage  String    @default("en")
  pinyinDisplayMode        String    @default("toneMarks") // 'toneMarks' or 'toneNumbers'
  proficiencyLevel         String    @default("beginner") // 'beginner', 'intermediate', 'advanced', 'native'
  onboardingCompleted      Boolean   @default(false)
  emailVerified            Boolean   @default(false)
  emailVerifiedAt          DateTime?

  // OAuth fields
  googleId                 String?   @unique

  // Subscription fields
  tier                     String    @default("free") // "free", "pro"
  stripeCustomerId         String?   @unique
  stripeSubscriptionId     String?   @unique
  stripeSubscriptionStatus String?   // "active", "canceled", "past_due", "incomplete"
  stripePriceId            String?   // Track which price they're on
  subscriptionStartedAt    DateTime?
  subscriptionExpiresAt    DateTime?
  subscriptionCanceledAt   DateTime?
  isTestUser               Boolean   @default(false) // Test users can access $0.01/month test tier

  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt

  episodes                 Episode[]
  courses                  Course[]
  narrowListeningPacks     NarrowListeningPack[]
  chunkPacks               ChunkPack[]
  inviteCode               InviteCode?
  generationLogs           GenerationLog[]
  emailVerificationTokens  EmailVerificationToken[]
  passwordResetTokens      PasswordResetToken[]
  subscriptionEvents       SubscriptionEvent[]
  oauthAccounts            OAuthAccount[]
  decks                    Deck[]
  cards                    Card[]
  reviews                  Review[]

  @@index([email])
  @@index([role])
  @@index([emailVerified])
  @@index([googleId])
  @@index([tier])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@index([isTestUser])
}

model InviteCode {
  id        String    @id @default(uuid())
  code      String    @unique
  usedBy    String?   @unique // User ID who used it
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User? @relation(fields: [usedBy], references: [id])

  @@index([code])
}

model EmailVerificationToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@map("email_verification_tokens")
}

model PasswordResetToken {
  id        String    @id @default(uuid())
  userId    String
  token     String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}

model SubscriptionEvent {
  id            String   @id @default(uuid())
  userId        String
  eventType     String   // "subscribed", "upgraded", "downgraded", "canceled", "reactivated"
  fromTier      String?
  toTier        String
  stripeEventId String?  @unique
  metadata      Json?
  createdAt     DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([eventType])
  @@index([createdAt])
  @@map("subscription_events")
}

model Episode {
  id             String   @id @default(uuid())
  userId         String
  title          String
  sourceText     String   @db.Text
  targetLanguage String   // Language code: 'ja', 'zh', etc.
  nativeLanguage String   // User's native language
  status         String   @default("draft") // draft, generating, ready, error

  // Legacy single-speed audio (for backward compatibility)
  audioUrl       String?
  audioSpeed     String?  @default("medium") // Legacy: very-slow, slow, medium, normal

  // Multi-speed audio URLs
  audioUrl_0_7   String?  // Slow (0.7x)
  audioUrl_0_85  String?  // Medium (0.85x)
  audioUrl_1_0   String?  // Normal (1.0x)

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  dialogue       Dialogue?
  images         Image[]
  courseEpisodes CourseEpisode[]

  @@index([userId])
  @@index([status])
}

model Dialogue {
  id        String   @id @default(uuid())
  episodeId String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  episode   Episode    @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  sentences Sentence[]
  speakers  Speaker[]

  @@index([episodeId])
}

model Speaker {
  id            String  @id @default(uuid())
  dialogueId    String
  name          String
  voiceId       String  // TTS voice ID (Google or Polly)
  voiceProvider String? @default("google") // "google" | "polly"
  proficiency   String  // beginner, intermediate, advanced, native
  tone          String  // casual, polite, formal
  gender        String? // male or female (for avatar matching)
  color         String? // For UI differentiation
  avatarUrl     String? // URL to speaker avatar image

  dialogue  Dialogue   @relation(fields: [dialogueId], references: [id], onDelete: Cascade)
  sentences Sentence[]

  @@index([dialogueId])
}

model Sentence {
  id          String   @id @default(uuid())
  dialogueId  String
  speakerId   String
  order       Int
  text        String   @db.Text
  translation String   @db.Text

  // Language-specific metadata stored as JSON
  // Structure: { japanese?: { kanji, kana, furigana }, chinese?: { characters, pinyin }, ... }
  metadata    Json

  // Legacy single-speed timing (for backward compatibility)
  audioUrl    String?
  startTime   Int?     // milliseconds
  endTime     Int?     // milliseconds

  // Multi-speed timings
  startTime_0_7  Int?  // milliseconds at 0.7x speed
  endTime_0_7    Int?  // milliseconds at 0.7x speed
  startTime_0_85 Int?  // milliseconds at 0.85x speed
  endTime_0_85   Int?  // milliseconds at 0.85x speed
  startTime_1_0  Int?  // milliseconds at 1.0x speed
  endTime_1_0    Int?  // milliseconds at 1.0x speed

  variations  Json?    // Array of alternative phrasings
  selected    Boolean  @default(false)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  dialogue    Dialogue @relation(fields: [dialogueId], references: [id], onDelete: Cascade)
  speaker     Speaker  @relation(fields: [speakerId], references: [id])

  @@index([dialogueId])
  @@index([order])
}

model Image {
  id               String   @id @default(uuid())
  episodeId        String
  url              String
  prompt           String   @db.Text
  order            Int
  sentenceStartId  String?
  sentenceEndId    String?
  createdAt        DateTime @default(now())

  episode          Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  @@index([episodeId])
  @@index([order])
}

// Pimsleur-style Audio Course Models

model Course {
  id                       String   @id @default(uuid())
  userId                   String
  title                    String
  description              String?  @db.Text
  status                   String   @default("draft") // draft, generating, ready, error
  nativeLanguage           String   // L1 (e.g., 'en')
  targetLanguage           String   // L2 (e.g., 'ja', 'zh')
  maxLessonDurationMinutes Int      @default(30)
  l1VoiceId                String   // English narrator voice
  l1VoiceProvider          String?  @default("google") // "google" | "polly"
  jlptLevel                String?  // Target JLPT level: N5, N4, N3, N2, N1 (null = no specific level)
  hskLevel                 String?  // Target HSK level: HSK1, HSK2, HSK3, HSK4, HSK5, HSK6 (null = no specific level)
  cefrLevel                String?  // Target CEFR level: A1, A2, B1, B2, C1, C2 (for Spanish and French)
  speaker1Gender           String   @default("male") // Gender for first dialogue speaker: 'male' or 'female'
  speaker2Gender           String   @default("female") // Gender for second dialogue speaker: 'male' or 'female'
  speaker1VoiceId          String?  // Specific TTS voice ID for speaker 1 (overrides gender default)
  speaker1VoiceProvider    String?  @default("google") // "google" | "polly"
  speaker2VoiceId          String?  // Specific TTS voice ID for speaker 2 (overrides gender default)
  speaker2VoiceProvider    String?  @default("google") // "google" | "polly"
  scriptJson               Json?    // LessonScriptUnit[] - flattened from Lesson
  approxDurationSeconds    Int?     // Flattened from Lesson
  audioUrl                 String?  // Flattened from Lesson
  timingData               Json?    // Timing data for each script unit: { unitIndex, startTime, endTime }[]
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt

  user                     User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  coreItems                CourseCoreItem[]
  courseEpisodes           CourseEpisode[]

  @@index([userId])
  @@index([status])
}

model CourseEpisode {
  id        String @id @default(uuid())
  courseId  String
  episodeId String
  order     Int

  course    Course  @relation(fields: [courseId], references: [id], onDelete: Cascade)
  episode   Episode @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  @@unique([courseId, episodeId])
  @@index([courseId])
  @@index([episodeId])
}

model CourseCoreItem {
  id                String  @id @default(uuid())
  courseId          String
  textL2            String
  readingL2         String? // kana/pinyin
  translationL1     String
  complexityScore   Float
  sourceEpisodeId   String?
  sourceSentenceId  String?
  sourceUnitIndex   Int?    // Index in Course.scriptJson where this vocabulary appears
  components        Json?   // Pimsleur backward-build components: PhraseComponent[]

  course            Course  @relation(fields: [courseId], references: [id], onDelete: Cascade)
  cards             Card[]

  @@index([courseId])
}

// Narrow Listening Models

model NarrowListeningPack {
  id             String   @id @default(uuid())
  userId         String
  title          String
  topic          String   @db.Text
  targetLanguage String   @default("ja") // ISO 639-1 code (ja, zh, es)
  jlptLevel      String?  // N5, N4, N3, N2, N1 (for Japanese)
  hskLevel       String?  // HSK1-HSK6 (for Chinese)
  cefrLevel      String?  // A1, A2, B1, B2, C1, C2 (for Spanish and European languages)
  grammarFocus   String?  @db.Text
  status         String   @default("draft") // draft, generating, ready, error
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  versions       StoryVersion[]

  @@index([userId])
  @@index([status])
}

model StoryVersion {
  id             String   @id @default(uuid())
  packId         String
  variationType  String   // PAST_CASUAL, PRESENT_POLITE, FUTURE_POLITE, PARTICLE_FOCUS, etc.
  title          String   // Brief description (e.g., "Past, casual")
  voiceId        String   // Edge TTS voice ID for this version
  order          Int
  audioUrl_0_7   String?  // Slow audio (0.7x speed)
  audioUrl_0_85  String?  // Medium audio (0.85x speed)
  audioUrl_1_0   String?  // Normal audio (1.0x speed)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  pack           NarrowListeningPack @relation(fields: [packId], references: [id], onDelete: Cascade)
  segments       StorySegment[]

  @@index([packId])
  @@index([order])
}

model StorySegment {
  id                  String   @id @default(uuid())
  versionId           String
  order               Int
  targetText          String   @db.Text // Target language text (Japanese/Chinese)
  englishTranslation  String   @db.Text
  reading             String?  @db.Text // Furigana (Japanese) or Pinyin (Chinese)
  voiceId             String?  // Voice for this specific segment (for randomized speakers)
  voiceProvider       String?  @default("google") // "google" | "polly"
  audioUrl_0_7        String?  // Slow segment audio
  audioUrl_0_85       String?  // Medium segment audio
  audioUrl_1_0        String?  // Normal segment audio
  startTime_0_7       Int?     // milliseconds for 0.7x combined audio
  endTime_0_7         Int?     // milliseconds for 0.7x combined audio
  startTime_0_85      Int?     // milliseconds for 0.85x combined audio
  endTime_0_85        Int?     // milliseconds for 0.85x combined audio
  startTime_1_0       Int?     // milliseconds for 1.0x combined audio
  endTime_1_0         Int?     // milliseconds for 1.0x combined audio
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  version             StoryVersion @relation(fields: [versionId], references: [id], onDelete: Cascade)

  @@index([versionId])
  @@index([order])
  @@index([voiceId])
}

// Lexical Chunk Pack Models

model ChunkPack {
  id             String   @id @default(uuid())
  userId         String
  title          String
  theme          String   // e.g., "daily_routine", "travel", "business"
  targetLanguage String   @default("ja") // ISO 639-1 code (ja, es, fr, etc.)
  jlptLevel      String   // N5, N4, N3
  status         String   @default("draft") // draft, generating, ready, error
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  chunks         Chunk[]
  examples       ChunkExample[]
  stories        ChunkStory[]
  exercises      ChunkExercise[]

  @@index([userId])
  @@index([status])
  @@index([jlptLevel])
}

model Chunk {
  id            String  @id @default(uuid())
  packId        String
  order         Int
  form          String  // The chunk in Japanese (e.g., 「〜ておきます」)
  translation   String  // Natural English gloss
  literalGloss  String? // Optional literal meaning
  register      String  // "polite", "casual", "neutral"
  function      String  // Short usage description
  notes         String  @db.Text // 1-2 notes on nuance

  pack          ChunkPack      @relation(fields: [packId], references: [id], onDelete: Cascade)
  examples      ChunkExample[]

  @@index([packId])
  @@index([order])
}

model ChunkExample {
  id           String  @id @default(uuid())
  packId       String
  chunkId      String
  order        Int
  sentence     String  @db.Text // Japanese sentence using the chunk
  english      String  @db.Text // Translation
  contextNote  String? // Optional context (e.g., "friend to friend")
  audioUrl     String? // Deprecated: use audioUrl_0_85 instead
  audioUrl_0_7 String? // Audio at 0.7x speed
  audioUrl_0_85 String? // Audio at 0.85x speed
  audioUrl_1_0 String? // Audio at 1.0x speed

  pack        ChunkPack @relation(fields: [packId], references: [id], onDelete: Cascade)
  chunk       Chunk     @relation(fields: [chunkId], references: [id], onDelete: Cascade)

  @@index([packId])
  @@index([chunkId])
  @@index([order])
}

model ChunkStory {
  id        String   @id @default(uuid())
  packId    String
  title     String
  type      String   // "narrative" or "dialogue"
  storyText String   @db.Text // Full Japanese text
  english   String   @db.Text // Full translation
  audioUrl  String?  // Full story audio
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  pack      ChunkPack           @relation(fields: [packId], references: [id], onDelete: Cascade)
  segments  ChunkStorySegment[]

  @@index([packId])
}

model ChunkStorySegment {
  id                 String  @id @default(uuid())
  storyId            String
  order              Int
  japaneseText       String  @db.Text
  englishTranslation String  @db.Text
  audioUrl           String?
  startTime          Int?    // milliseconds
  endTime            Int?    // milliseconds

  story              ChunkStory @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@index([storyId])
  @@index([order])
}

model ChunkExercise {
  id            String   @id @default(uuid())
  packId        String
  order         Int
  exerciseType  String   // "chunk_to_meaning" | "meaning_to_chunk" | "gap_fill_mc"
  prompt        String   @db.Text // What user sees
  options       Json     // Array of option strings (2-3 options)
  correctOption String   // The correct answer
  explanation   String   @db.Text // Usage-based explanation
  audioUrl      String?  // For gap-fill exercises with audio

  pack          ChunkPack @relation(fields: [packId], references: [id], onDelete: Cascade)

  @@index([packId])
  @@index([order])
}

// Speaker Avatar Models - Store avatars in GCS

model SpeakerAvatar {
  id          String   @id @default(uuid())
  filename    String   @unique // e.g., "ja-female-casual.jpg"
  croppedUrl  String   // GCS public URL for cropped avatar
  originalUrl String   // GCS public URL for original/uncropped version
  language    String   // Language code: 'ja', 'zh', etc.
  gender      String   // 'male' or 'female'
  tone        String   // 'casual', 'polite', 'formal'
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([filename])
  @@index([language, gender, tone])
}

// Feature Flags - Control visibility of content types for non-admin users

model FeatureFlag {
  id                           String   @id @default(uuid())
  dialoguesEnabled             Boolean  @default(true)
  audioCourseEnabled           Boolean  @default(true)
  narrowListeningEnabled       Boolean  @default(true)
  processingInstructionEnabled Boolean  @default(true)
  lexicalChunksEnabled         Boolean  @default(true)
  updatedAt                    DateTime @updatedAt

  @@map("feature_flags")
}

// Admin Audit Log - Track admin actions for compliance and security

model AdminAuditLog {
  id           String   @id @default(uuid())
  adminUserId  String   // Admin who performed action
  action       String   // "impersonate_start", "impersonate_end", etc.
  targetUserId String?  // User being impersonated (if applicable)
  metadata     Json?    // Additional context (e.g., IP, user agent)
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())

  @@index([adminUserId])
  @@index([action])
  @@index([createdAt])
  @@map("admin_audit_logs")
}

// Generation Log - Track content generation events for rate limiting
// Persists even if content is deleted to prevent quota gaming

model GenerationLog {
  id          String   @id @default(uuid())
  userId      String
  contentType String   // "dialogue", "course", "narrow_listening", "chunk_pack", "pi_session"
  contentId   String?  // Optional reference to generated content
  createdAt   DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, createdAt])
  @@index([createdAt])
  @@map("generation_logs")
}

// OAuth Account - Store OAuth provider tokens and metadata

model OAuthAccount {
  id           String    @id @default(uuid())
  userId       String
  provider     String    // "google", "github", etc.
  providerId   String    // Provider's unique ID for the user
  accessToken  String?   @db.Text
  refreshToken String?   @db.Text
  expiresAt    DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerId])
  @@index([userId])
  @@map("oauth_accounts")
}

// SRS (Spaced Repetition System) Models

model Deck {
  id          String   @id @default(uuid())
  userId      String
  language    String   // ISO 639-1 code (ja, zh, es)
  name        String
  description String?  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  cards       Card[]

  @@unique([userId, language])
  @@index([userId])
  @@index([language])
}

model Card {
  id                  String   @id @default(uuid())
  deckId              String
  userId              String
  coreItemId          String?

  // Denormalized content
  textL2              String
  readingL2           String?
  translationL1       String
  audioUrl            String?
  imageUrl            String?

  // Full sentence context (for displaying on card back)
  sentenceL2          String?
  sentenceReadingL2   String?
  sentenceTranslationL1 String?

  // FSRS State - Recognition Cards (L2 → L1)
  recognitionState    String   @default("new")
  recognitionDue      DateTime @default(now())
  recognitionStability Float?
  recognitionDifficulty Float?
  recognitionElapsedDays Int   @default(0)
  recognitionScheduledDays Int @default(0)
  recognitionReps     Int      @default(0)
  recognitionLapses   Int      @default(0)
  recognitionLastReview DateTime?

  // FSRS State - Audio Cards (Audio → L2 + L1)
  audioState          String   @default("new")
  audioDue            DateTime @default(now())
  audioStability      Float?
  audioDifficulty     Float?
  audioElapsedDays    Int      @default(0)
  audioScheduledDays  Int      @default(0)
  audioReps           Int      @default(0)
  audioLapses         Int      @default(0)
  audioLastReview     DateTime?

  // Card settings
  enableRecognition   Boolean  @default(true)
  enableAudio         Boolean  @default(true)
  tags                String[]
  notes               String?  @db.Text
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  deck                Deck     @relation(fields: [deckId], references: [id], onDelete: Cascade)
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  coreItem            CourseCoreItem? @relation(fields: [coreItemId], references: [id], onDelete: SetNull)
  reviews             Review[]

  @@index([deckId])
  @@index([userId])
  @@index([coreItemId])
  @@index([recognitionDue])
  @@index([audioDue])
  @@index([recognitionState])
  @@index([audioState])
}

model Review {
  id            String   @id @default(uuid())
  cardId        String
  userId        String
  cardType      String   // "recognition" or "audio"
  rating        Int      // 1 (Again), 2 (Hard), 3 (Good), 4 (Easy)

  stateBefore   String
  stateAfter    String
  dueBefore     DateTime
  dueAfter      DateTime

  reviewedAt    DateTime @default(now())
  durationMs    Int?

  card          Card     @relation(fields: [cardId], references: [id], onDelete: Cascade)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([cardId])
  @@index([userId])
  @@index([reviewedAt])
  @@index([cardType])
}
